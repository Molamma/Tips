Web applicatio VAPT Tips

HTTP Response Codes

1XX = Informational
2XX = Request successfully
3XX = Redirects
4XX = Client Request Error
5XX = Server side error

RFC 2069

realm = set by server admin
nonce = a random string 
opaque= a random string
uri = you need acces to this 
response = cross match this to authenticate

Hash1= MD5(Username:Relm:Password)
Hash2= MD5(method:URI)
response = MD5(HAsh1:nonce:HAsh2)

Create response string using python
#python
>>>import hashlib
>>>hash1 = hashlib.md5('admin:relm:password').hexdigest()
>>>hash2 = hashlib.md5('GET:URI').hexdigest()
>>>nonce= "enter the nonce"
>>>responce_string = hash1 + ':' + nonce + ':' + hash2
>>>responce = hashlib.md5(response_string).hexdigest()
>>>

RFC 2617



relam = set by server admin
qop = "auth,auth-int"  //QOP quality of protection implimentation
nonce = sent by server
opaque =  same in responce and request 
uri = secured resource location
nc = counter
cnonce = client nonce
response =   //

Hash1= MD5(Username:Relm:Password)
Hash2= MD5(method:URI)
response = MD5(HAsh1:Nonce:NonceCount:Client_nonce:QOP:HAsh2)

Create response string using python
#python
>>>import hashlib
>>>hash1 = hashlib.md5('admin:relm:password').hexdigest()
>>>hash2 = hashlib.md5('GET:URI').hexdigest()
>>>nonce= "enter the nonce"
>>>nonceCount = "enter the nonceCount"
>>>clientNonce = "enter the cnonce"
>>>qop = "auth"
>>>responce_string = hash1 + ':' + nonce + ':' + nonceCount + ':' + clientNonce + ':' + qop +  ':' + hash2
>>>responce = hashlib.md5(response_string).hexdigest()
>>>

Cookies

HTTP is a stateless protocal cookies are used to overcome this
size limit is K

Server end syntax
Set-Cookie: <name>=<value>[; <name>=<value>]...[; expires=<date>][; domain=<domain_name>][; path=<some_path>][; secure][; httponly]
<name>=<value>. //this shoud be any value
expires=<date> // expiray date of the cookie format is DD-MM-YYY HH:MM:SS GMT ,RFC 6265 have Max-age intervel after the cookie recives
domain=<domain_name> // domain for which it is valid
path=<some_path> // path of for the cookie
secure // only be sent over HTTPS connection, Transport layr protction
httponly // cannot be accessed by client side scripts directly, cannot be scripted using js ,XSS mitigation machanisam

Client end syntax
Cookie: <name>=<value> [;<name>=<value>]

Session

Unique identfier or token to identify a user and Session

SSL




CURL

# curl -v www.abc.com // to view a website using curl
#  curl -v -X POST http://abc.com/abc/   //curl used post request



NETCAT


# nc www.abc.com 80   //manualy requesting to a webserver in http 1.0
> GET / HTTP/1.0.  //http 1.0
>Host: www.abc.com

# nc www.abc.com 80.    //manualy requesting to a webserver in http 1.1 
> GET / HTTP/1.1  //http 1.1
>Host: www.abc.com
> Connection: close


NMAP

Script location /usr/share/namp/scripts/
1) http option scaning
# nmap --script=http-methods.nse --script-args=http-methods.retest=1 (ip/Host_details) -n -p 80. //test options indudaly 
2) Http bruteforce
#namp -p 80 --scripthttp-brute --script-args 'http-brute.hostname={host name},http-brute.method=POST,http-brute.path={path},userdb={username list file},passdb={password list file}' -v {hostname} -n //brutefore web form using nmap
#

METASPLOIT

search "module_name" //you can search modules in metasploit

1) http options scaning
# msfconsole 
msf> set RHOSTS (Host_details)
msf> use auxiliary/scanner/http/options
msf>run //it will show the options availble on RHOSTS
2) http bruteforce
# msfconsole 
msf> use auxiliary/scanner/http/http_login
msf> set RHOSTS {host_name}
msf> set AUTH_URI {uri}
msf> set BLANK_PASSWORDS fals
msf> set PASS_FILE {password_file}
msf> set REQUESTTYPE POST
msf> set STOP_ON_SUCC?ESS true
msf> set THREADS 20
msf> set USERNAME admin         //you can use USER_FILE insted of this
msf> set VHOST {hostname}
msf>set USER_AS_PASS false 
msf> set USERPASS_FILE ''
msf> set USER_FILE ''
msf> run




WIRESHARK


